# TypeScript для JS програмістів

TypeScript знаходиться у незвичних відносинах з JavaScript. TypeScript пропонує всі можливості JavaScript, а також додатковий рівень над ними: Система типів TypeScript.

Наприклад, JavaScript надає мовні примітиви типу `string` і `number`, але він не перевіряє, чи послідовно ви їх призначили. TypeScript перевіряє.

Це значить, що ваш існуючий та працюючий код JavaScript це також код TypeScript. Основна перевага TypeScript полягає в тому, що він може підсвічувати неочікувану поведінку у вашому коді, знижуючи ймовірність появи помилок.

Цей туторіал надає короткий огляд TypeScript, зосереджуючись на його системі типів.

## Типи за висновком
TypeScript знає мову JavaScript та згенерує типи для вас у багатьох випадках. Наприклад, при створенні змінної та присвоєнні їй певного значення, TypeScript буде використовувати це значення як її тип.

```
let helloWorld = "Hello World"; -> let helloWorld: string
```

Розуміючи як працює JavaScript, TypeScript може побудувати систему типів, яка приймає код JavaScript, але має типи.
Цей спосіб пропонує систему типів без необхідності додавання додаткових символів, щоб зробити типи явними у вашому коді. Ось як TypeScript дізнається, що helloWorld - це `string` у наведеному вище прикладі.

Можливо, ви писали JavaScript у Visual Studio Code і використовували автозавершення редактора. Visual Studio Code використовує TypeScript, щоб полегшити роботу з JavaScript.

## Визначення типів
Ви можете використовувати широкий спектр шаблонів дизайну в JavaScript. Однак деякі шаблони ускладнюють автоматичне визначення типів (наприклад, шаблони, що використовують динамічне програмування). Для таких випадків TypeScript підтримує розширення мови JavaScript, яке пропонує місця, де ви можете вказати TypeScript, якими мають бути типи.

Наприклад, щоб створити об'єкт з виведеним типом, який включає `name: string` та `id: number`:, ви можете написати:

```
const user = {
  name: "Hayes",
  id: 0,
};
```

Ви можете чітко описати форму цього об'єкта за допомогою оголошення інтерфейсу:

```
interface User {
  name: string;
  id: number;
}
```


Потім ви можете оголосити, що об'єкт JavaScript відповідає формі вашого нового інтерфейсу, використовуючи синтаксис на кшталт `: TypeName` після оголошення змінної:

```
const user: User = {
  name: "Hayes",
  id: 0,
};
```

Якщо ви надасте об'єкт, який не відповідає наданому інтерфейсу, TypeScript попередить вас про це:

```
interface User {
  name: string;
  id: number;
}
 
const user: User = {
  username: "Hayes",
Тип '{ username: string; id: number; }' не може бути присвоєний типу 'User'.
  Об'єктний літерал може вказувати лише відомі властивості, а "username" не існує в типі "User".
  id: 0,
};
```

Оскільки JavaScript підтримує класи та об'єктно-орієнтоване програмування, TypeScript також підтримує їх. Ви можете використовувати оголошення інтерфейсу з класами:

```
interface User {
  name: string;
  id: number;
}
 
class UserAccount {
  name: string;
  id: number;
 
  constructor(name: string, id: number) {
    this.name = name;
    this.id = id;
  }
}
 
const user: User = new UserAccount("Murphy", 1);
```

Ви можете використовувати інтерфейси для коментування параметрів і повернення значень функціям:

```
function getAdminUser(): User {
  //...
}
 
function deleteUser(user: User) {
  // ...
}
```

У JavaScript вже існує невеликий набір примітивних типів: `boolean`, `bigint`, `null`, `number`, `string`, `symbol` та `undefined`, який ви можете використовувати в інтерфейсах. TypeScript розширює цей список ще кількома, такими як any (дозволено все), unknown (переконайтеся, що той, хто використовує цей тип, оголошує, що це за тип), never (неможливо, щоб цей тип трапився) і void (функція, яка повертає невизначене значення або не має значення, що повертається).

Ви побачите, що існує два синтаксиси для створення типів: [Інтерфейси та Типи](https://www.typescriptlang.org/play/?e=83#example/types-vs-interfaces). Вам слід надавати перевагу інтерфейсу. Використовуйте тип, коли вам потрібні специфічні можливості.

## Типи складання
З TypeScript ви можете створювати складні типи, комбінуючи прості. Існує два популярних способи зробити це: за допомогою об'єднань та узагальнень.

### Об'єднання
За допомогою об'єднання ви можете оголосити, що тип може бути одним з багатьох типів. Наприклад, ви можете описати тип `boolean` як `true` або `false`:

```
type MyBool = true | false;
```

*Зверніть увагу:* Якщо ви наведете курсор на `MyBool` вище, (доступно тільки на оригінальному сайті) то ви побачите, що він класифікується як `boolean`. Це властивість системи структурних типів. Детальніше про це нижче.

Популярним варіантом використання типів об'єднання є опис набору `string` або `number` літералів, якими може бути значення:

```
type WindowStates = "open" | "closed" | "minimized";
type LockStates = "locked" | "unlocked";
type PositiveOddNumbersUnderTen = 1 | 3 | 5 | 7 | 9;
```

Об'єднання також дозволяють працювати з різними типами. Наприклад, у вас може бути функція, яка приймає `array` (масив) або `string` (рядок):

```
function getLength(obj: string | string[]) {
  return obj.length;
}
```

Щоб дізнатися тип змінної, використовуйте `typeof`:

| Тип       | Предикат                         |
|-----------|----------------------------------|
| string    | typeof s === "string"            |
| number    | typeof n === "number"            |
| boolean   | typeof b === "boolean"           |
| undefined | typeof undefined === "undefined" |
| function  | typeof f === "function"          |
| array     | Array.isArray(a)                 |

Наприклад, ви можете зробити так, щоб функція повертала різні значення залежно від того, чи передається їй рядок, чи масив:

```
function wrapInArray(obj: string | string[]) {
  if (typeof obj === "string") {
    return [obj];
  }
  return obj;
}
```

```
(parameter) obj: string
```

### Узагальнення
Узагальнення надають типам змінні. Типовим прикладом є масив. Масив без узагальнень може містити будь-що. Масив з узагальненнями може описувати значення, які містить масив.

```
type StringArray = Array<string>;
type NumberArray = Array<number>;
type ObjectWithNameArray = Array<{ name: string }>;
```

Ви можете оголошувати власні типи, які використовують узагальнення:

```
interface Backpack<Type> {
  add: (obj: Type) => void;
  get: () => Type;
}
 
// Цей рядок є ярликом для повідомлення TypeScript про те, що є константа
// константа з іменем `backpack`, і не турбуватися про те, звідки вона взялася.
declare const backpack: Backpack<string>;
 
// об'єкт є рядком, тому що ми оголосили його вище як змінну частину Backpack.
const object = backpack.get();
 
// Оскільки змінна backpack є рядком, то у функцію add не можна передати число.
backpack.add(23);
```

```
Аргумент типу число не може бути присвоєний параметру типу рядок.
```

## Система структурного типу
Один з основних принципів TypeScript полягає в тому, що перевірка типу фокусується на формі, яку мають значення. Іноді це називають "качиною типізацією" або "структурною типізацією".

У системі структурних типів, якщо два об'єкти мають однакову форму, вони вважаються одного типу.

```
interface Point {
  x: number;
  y: number;
}
 
function logPoint(p: Point) {
  console.log(`${p.x}, ${p.y}`);
}
 
// logs "12, 26"
const point = { x: 12, y: 26 };
logPoint(point);
```

Змінна `point` ніколи не оголошується як тип `Point`. Однак, TypeScript порівнює форму `point` формою типу `Point` при перевірці типу. Вони мають однакову форму, тому код проходить.

Порівняння форми вимагає збігу лише підмножини полів об'єктів.

```
const point3 = { x: 12, y: 26, z: 89 };
logPoint(point3); // logs "12, 26"
 
const rect = { x: 33, y: 3, width: 30, height: 80 };
logPoint(rect); // logs "33, 3"
 
const color = { hex: "#187ABF" };
logPoint(color);
```

```
Аргумент типу '{ hex: string; }' не може бути присвоєний параметру типу 'Point'.
  Тип '{ hex: string; }' не має наступних властивостей від типу 'Point': x, y
```
Немає різниці між тим, як класи та об'єкти відповідають формам:

```
class VirtualPoint {
  x: number;
  y: number;
 
  constructor(x: number, y: number) {
    this.x = x;
    this.y = y;
  }
}
 
const newVPoint = new VirtualPoint(13, 56);
logPoint(newVPoint); // виводить "13, 56"
```

Якщо об'єкт або клас має всі необхідні властивості, TypeScript скаже, що вони збігаються, незалежно від деталей реалізації.
